<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>人工智能数学基础书单</title>
    <link href="/2023/02/23/artificial%20intelligence/%E4%B9%A6%E5%8D%95/"/>
    <url>/2023/02/23/artificial%20intelligence/%E4%B9%A6%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<ul><li>张筑生. 数学分析新讲</li><li>史蒂文J.利昂. 线性代数</li><li>Horn R, Johnson C. 矩阵分析</li><li>Boyd S. 凸优化</li><li>Bertsekas D. 非线性规划 第三版</li><li>欧斐君. 变分法及其应用：物理、力学、工程中的经典建模</li><li>Sra S, Nowozin S, Wright SJ. Optimization for machine learning</li><li>盛骤. 概率论与数理统计 第九版</li><li>Ross S. 随机过程 第二版</li><li>West D. 图论导引</li></ul>]]></content>
    
    
    <categories>
      
      <category>artificial intelligence</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习相关技巧</title>
    <link href="/2022/11/10/artificial%20intelligence/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/11/10/artificial%20intelligence/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>本节主要讲述参数的更新、权重初始值、Batch Normalization方法、正则化、超参数的验证。</p><h2 id="1-参数的更新"><a href="#1-参数的更新" class="headerlink" title="1.参数的更新"></a>1.参数的更新</h2><p>神经网络的学习的目的是找到使损失函数的值尽可能小的参数。这是寻找最优参数的问题，解决这个问题的过程称为最优化（optimization）</p><h3 id="1-1-SGD"><a href="#1-1-SGD" class="headerlink" title="1.1 SGD"></a>1.1 SGD</h3><p>使用参数的梯度，沿梯度方向更新参数，并重复这个步骤多次，从而逐渐靠近最优参数，这个过程称为随机梯度下降法（stochastic gradient descent），简称 SGD。<br>$$<br>W \leftarrow W-\eta\frac{\partial L}{\partial W}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SGD</span>:<br><br>    <span class="hljs-string">&quot;&quot;&quot;随机梯度下降法（Stochastic Gradient Descent）&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, lr=<span class="hljs-number">0.01</span></span>):<br>        self.lr = lr<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, params, grads</span>):<br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> params.keys():<br>            params[key] -= self.lr * grads[key] <br><br></code></pre></td></tr></table></figure><p>SGD 呈“之”字形移动。这是一个相当低效的路径。SGD 的<strong>缺点</strong>是，如果函数的形状非均向（anisotropic），比如呈延伸状，搜索的路径就会非常低效。SGD 低效的根本原因是，梯度的方向并没有指向最小值的方向。</p><p>以下都以$f(x,y) = \frac{1}{20} x^2 + y^2$为例</p><img src="/2022/11/10/artificial%20intelligence/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7/基于SGD的最优化的更新路径.png"><h3 id="1-2-Momentum"><a href="#1-2-Momentum" class="headerlink" title="1.2 Momentum"></a>1.2 Momentum</h3><p>Momentum 是“动量”的意思，和物理有关。用数学式表示 Momentum 方法，如下所示。<br>$$<br>\begin{aligned}<br>v \leftarrow \alpha v-\eta \frac{\partial L}{\partial W}\\<br>W \leftarrow W+v<br>\end{aligned}<br>$$<br>这里新出现了一个变量 v，对应物理上的速度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Momentum</span>:<br><br>    <span class="hljs-string">&quot;&quot;&quot;Momentum SGD&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, lr=<span class="hljs-number">0.01</span>, momentum=<span class="hljs-number">0.9</span></span>):<br>        self.lr = lr<br>        self.momentum = momentum<br>        self.v = <span class="hljs-literal">None</span><br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, params, grads</span>):<br>        <span class="hljs-keyword">if</span> self.v <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.v = &#123;&#125;<br>            <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> params.items():                                <br>                self.v[key] = np.zeros_like(val)<br>                <br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> params.keys():<br>            self.v[key] = self.momentum*self.v[key] - self.lr*grads[key] <br>            params[key] += self.v[key]<br></code></pre></td></tr></table></figure><p>和 SGD 相比，我们发现“之”字形的“程度”减轻了。这是因为虽然 x 轴方向上受到的力非常小，但是一直在同一方向上受力，所以朝同一个方向会有一定的加速。反过来，虽然 y 轴方向上受到的力很大，但是因为交互地受到正方向和反方向的力，它们会互相抵消，所以 y 轴方向上的速度不稳定。因此，和 SGD 时的情形相比，可以更快地朝 x 轴方向靠近，减弱“之”字形的变动程度。</p><img src="/2022/11/10/artificial%20intelligence/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7/基于Momentum的最优化的更新路径.png"><h3 id="1-3-AdaGrad"><a href="#1-3-AdaGrad" class="headerlink" title="1.3. AdaGrad"></a>1.3. AdaGrad</h3><p>在神经网络的学习中，学习率（数学式中记为 η）的值很重要。学习率过小，会导致学习花费过多时间；反过来，学习率过大，则会导致学习发散而不能正确进行。</p><p>在关于学习率的有效技巧中，有一种被称为学习率衰减（learning ratedecay）的方法，即随着学习的进行，使学习率逐渐减小。实际上，一开始“多”学，然后逐渐“少”学的方法，在神经网络的学习中经常被使用。</p><p>AdaGrad 会为参数的每个元素适当地调整学习率，与此同时进行学习（AdaGrad 的 Ada 来自英文单词 Adaptive，即“适当的”的意思）。<br>$$<br>\begin{aligned}<br>h \leftarrow h + \frac{\partial L} {\partial W} .* \frac{\partial L} {\partial W}\\<br>W \leftarrow W -\eta \frac{1} {\sqrt{h} } \frac{\partial L} {\partial W}<br>\end{aligned}<br>$$<br>这里新出现了变量 h，如上式 所示，它保存了以前的所有梯度值的平方和（式中的 .* 表示对应矩阵元素的乘法）</p><p><strong>注</strong>：AdaGrad 会记录过去所有梯度的平方和。因此，学习越深入，更新的幅度就越小。实际上，如果无止境地学习，更新量就会变为 0，完 全 不 再 更 新。为 了 改 善 这 个 问 题，可 以 使 用 RMSProp方 法。RMSProp 方法并不是将过去所有的梯度一视同仁地相加，而是逐渐地遗忘过去的梯度，在做加法运算时将新梯度的信息更多地反映出来。这种操作从专业上讲，称为“指数移动平均”，呈指数函数式地减小过去的梯度的尺度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdaGrad</span>:<br><br>    <span class="hljs-string">&quot;&quot;&quot;AdaGrad&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, lr=<span class="hljs-number">0.01</span></span>):<br>        self.lr = lr<br>        self.h = <span class="hljs-literal">None</span><br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, params, grads</span>):<br>        <span class="hljs-keyword">if</span> self.h <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.h = &#123;&#125;<br>            <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> params.items():<br>                self.h[key] = np.zeros_like(val)<br>            <br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> params.keys():<br>            self.h[key] += grads[key] * grads[key]<br>            params[key] -= self.lr * grads[key] / (np.sqrt(self.h[key]) + <span class="hljs-number">1e-7</span>)<br></code></pre></td></tr></table></figure><img src="/2022/11/10/artificial%20intelligence/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7/基于AdaGrad的最优化的更新路径.png"><h3 id="1-4-Adam"><a href="#1-4-Adam" class="headerlink" title="1.4 Adam"></a>1.4 Adam</h3><p>Momentum 参照小球在碗中滚动的物理规则进行移动，AdaGrad 为参数的每个元素适当地调整更新步伐。如果将这两个方法融合在一起会怎么样呢？这就是 Adam 方法的基本思路。</p><img src="/2022/11/10/artificial%20intelligence/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7/基于 Adam 的最优化的更新路径.png"><h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p>这 4 种方法各有各的特点，都有各自擅长解决的问题和不擅长解决的问题。很多研究中至今仍在使用 SGD。Momentum 和 AdaGrad 也是值得一试的方法。最近，很多研究人员和技术人员都喜欢用 Adam。</p><h2 id="2-权重的初始值"><a href="#2-权重的初始值" class="headerlink" title="2. 权重的初始值"></a>2. 权重的初始值</h2><p>在神经网络的学习中，权重的初始值特别重要。实际上，设定什么样的权重初始值，经常关系到神经网络的学习能否成功。</p><h3 id="2-1-可以将权重初始值设为-0-吗"><a href="#2-1-可以将权重初始值设为-0-吗" class="headerlink" title="2.1 可以将权重初始值设为 0 吗"></a>2.1 可以将权重初始值设为 0 吗</h3><p>事实上，将权重初始值设为0 的话，将无法正确进行学习。</p><p><strong>为什么不能将权重初始值设为 0 呢？</strong>严格地说，<strong>为什么不能将权重初始值设成一样的值呢？</strong>这是因为在误差反向传播法中，所有的权重值都会进行相同的更新。比如，在 2 层神经网络中，假设第 1 层和第 2 层的权重为 0。这样一来，正向传播时，因为输入层的权重为 0，所以第 2 层的神经元全部会被传递相同的值。第 2 层的神经元中全部输入相同的值，这意味着反向传播时第 2 层的权重全部都会进行相同的更新。因此，权重被更新为相同的值，并拥有了对称的值（重复的值）。这使得神经网络拥有许多不同的权重的意义丧失了。为了防止“权重均一化”（严格地讲，是为了瓦解权重的对称结构），必须随机生成初始值。</p><h3 id="2-2-隐藏层的激活值的分布"><a href="#2-2-隐藏层的激活值的分布" class="headerlink" title="2.2 隐藏层的激活值的分布"></a>2.2 隐藏层的激活值的分布</h3><p>观察隐藏层的激活值 （激活函数的输出数据）的分布，可以获得很多启发。这里，我们来做一个简单的实验，观察权重初始值是如何影响隐藏层的激活值的分布的。</p><p>实验参考了斯坦福大学的课程 CS231n。</p><img src="/2022/11/10/artificial%20intelligence/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7/使用标准差为 1 的高斯分布作为权重初始值时的各层激活值的分布.png"><p>从图可知，各层的激活值呈偏向 0 和 1 的分布。这里使用的 sigmoid函数是 S 型函数，随着输出不断地靠近 0（或者靠近 1），它的导数的值逐渐接近 0。因此，偏向 0 和 1 的数据分布会造成反向传播中梯度的值不断变小，最后消失。这个问题称为梯度消失（gradient vanishing）。层次加深的深度学习中，梯度消失的问题可能会更加严重。</p><p>接着，我们尝试使用 Xavier Glorot 等人的论文中推荐的权重初始值（俗称“Xavier 初始值”）。现在，在一般的深度学习框架中，Xavier 初始值已被作为标准使用。<strong>推导出的结论是，如果前一层的节点数为 n，则初始值使用标准差为 $1\sqrt{n}$ 的分布 。</strong></p><h3 id="2-3-ReLU-的权重初始值"><a href="#2-3-ReLU-的权重初始值" class="headerlink" title="2.3 ReLU 的权重初始值"></a>2.3 ReLU 的权重初始值</h3><p>Xavier 初始值是以激活函数是线性函数为前提而推导出来的。因为sigmoid 函数和 tanh 函数左右对称，且中央附近可以视作线性函数，所以适合使用 Xavier 初始值。但当激活函数使用 ReLU 时，一般推荐使用 ReLU 专用的初始值，也就是 Kaiming He 等人推荐的初始值，也称为<strong>“He 初始值”</strong>。</p><p>当前一层的节点数为 n 时，He 初始值使用标准差为$\sqrt{\frac{2}{n}}$ 的高斯分布。当Xavier 初始值是$\sqrt{\frac{1}{n}}$ 时，（直观上）可以解释为，因为 ReLU 的负值区域的值为 0，为了使它更有广度，所以需要 2 倍的系数。</p><h2 id="3-Batch-Normalization"><a href="#3-Batch-Normalization" class="headerlink" title="3. Batch Normalization"></a>3. Batch Normalization</h2><p>我们观察了各层的激活值分布，并从中了解到如果设定了合适的权重初始值，则各层的激活值分布会有适当的广度，从而可以顺利地进行学习。那么，为了使各层拥有适当的广度，“强制性”地调整激活值的分布会怎样呢？实际上，Batch Normalization方法就是基于这个想法而产生的。</p><p>Batch Norm 虽然是一个问世不久的新方法，但已经被很多研究人员和技术人员广泛使用。实际上，看一下机器学习竞赛的结果，就会发现很多通过使用这个方法而获得优异结果的例子。</p><p> Batch Norm 有以下优点:</p><ul><li>可以使学习快速进行（可以增大学习率）。</li><li>不那么依赖初始值（对于初始值不用那么神经质）。</li><li>抑制过拟合（降低 Dropout 等的必要性）。</li></ul><p>Batch Norm 的思路是调整各层的激活值分布使其拥有适当的广度。为此，要向神经网络中插入对数据分布进行正规化的层，即 Batch Normalization 层（下文简称 Batch Norm 层），如图所示。</p><img src="/2022/11/10/artificial%20intelligence/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7/使用了 Batch Normalization 的神经网络的例子.png"><p>Batch Norm，顾名思义，以进行学习时的 mini-batch 为单位，按 mini-batch 进行正规化。具体而言，就是进行使数据分布的均值为 0、方差为 1 的正规化。用数学式表示的话，如下所示。</p><img src="/2022/11/10/artificial%20intelligence/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7/Batch Norm公式.png"><p>这里对 mini-batch 的 m 个输入数据的集合 B = {x1, x2, . . . , xm} 求均值μB 和方差 。然后，对输入数据进行均值为 0、方差为 1（合适的分布）的正规化。式中的 ε 是一个微小值（比如，10e-7 等），它是为了防止出现除以 0 的情况。</p><p>式子所做的是将 mini-batch 的输入数据 {x1, x2, . . . , xm} 变换为均值为 0、方差为 1 的数据，非常简单。通过将这个处理插入到激活函数的前面（或者后面），可以减小数据分布的偏向。</p><p>接着，Batch Norm 层会对正规化后的数据进行缩放和平移的变换，用数学式可以如下表示。<br>$$<br>y_i \leftarrow \gamma \hat{x_i} + \beta<br>$$<br>这里，γ 和 β 是参数。一开始 γ = 1，β = 0，然后再通过学习调整到合适的值。</p><p>Batch Norm 的反向传播的推导有些复杂，这里我们不进行介绍。</p><h2 id="4-正则化"><a href="#4-正则化" class="headerlink" title="4. 正则化"></a>4. 正则化</h2><p>过拟合指的是只能拟合训练数据，但不能很好地拟合不包含在训练数据中的其他数据的状态。</p><h3 id="4-1-过拟合"><a href="#4-1-过拟合" class="headerlink" title="4.1 过拟合"></a>4.1 过拟合</h3><p>发生过拟合的原因，主要有以下两个。</p><p>• 模型拥有大量参数、表现力强。<br>• 训练数据少。</p><h3 id="4-2-权值衰减"><a href="#4-2-权值衰减" class="headerlink" title="4.2 权值衰减"></a>4.2 权值衰减</h3><p>权值衰减是一直以来经常被使用的一种抑制过拟合的方法。该方法通过在学习的过程中对大的权重进行惩罚，来抑制过拟合。很多过拟合原本就是因为<strong>权重参数取值过大</strong>才发生的。</p><img src="/2022/11/10/artificial%20intelligence/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7/权值衰减原文.png"><h3 id="4-3-Dropout"><a href="#4-3-Dropout" class="headerlink" title="4.3 Dropout"></a>4.3 Dropout</h3><p>如果网络的模型变得很复杂，只用权值衰减就难以应对了。在这种情况下，我们经常会使用 Dropout 方法。</p><p>Dropout 是一种在学习的过程中随机删除神经元的方法。训练时，随机选出隐藏层的神经元，然后将其删除。被删除的神经元不再进行信号的传递。训练时，每传递一次数据，就会随机选择要删除的神经元。然后，测试时，虽然会传递所有的神经元信号，但是对于各个神经元的输出，要乘上训练时的删除比例后再输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dropout</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    http://arxiv.org/abs/1207.0580</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, dropout_ratio=<span class="hljs-number">0.5</span></span>):<br>        self.dropout_ratio = dropout_ratio<br>        self.mask = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x, train_flg=<span class="hljs-literal">True</span></span>):<br>        <span class="hljs-keyword">if</span> train_flg:<br>            self.mask = np.random.rand(*x.shape) &gt; self.dropout_ratio<br>            <span class="hljs-keyword">return</span> x * self.mask<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> x * (<span class="hljs-number">1.0</span> - self.dropout_ratio)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, dout</span>):<br>        <span class="hljs-keyword">return</span> dout * self.mask<br></code></pre></td></tr></table></figure><p>注：机器学习中经常使用集成学习。所谓集成学习，就是让多个模型单独进行学习，推理时再取多个模型的输出的平均值。用神经网络的语境来说，比如，准备 5 个结构相同（或者类似）的网络，分别进行学习，<strong>测试时，以这 5 个网络的输出的平均值作为答案</strong>。实验告诉我们，通过进行集成学习，神经网络的识别精度可以提高好几个百分点。这个集成学习与 Dropout 有密切的关系。这是因为可以将 Dropout理解为，通过在学习过程中随机删除神经元，从而每一次都让不同<br>的模型进行学习。并且，推理时，通过对神经元的输出乘以删除比例（比如，0.5 等），可以取得模型的平均值。也就是说，可以理解成，Dropout 将集成学习的效果（模拟地）通过一个网络实现了。</p><h2 id="5-超参数的验证"><a href="#5-超参数的验证" class="headerlink" title="5. 超参数的验证"></a>5. 超参数的验证</h2><p>神经网络中，除了权重和偏置等参数，超参数（hyper-parameter）也经常出现。这里所说的超参数是指，比如各层的神经元数量、batch 大小、参数更新时的学习率或权值衰减等。如果这些超参数没有设置合适的值，模型的性能就会很差。虽然超参数的取值非常重要，但是在决定超参数的过程中一般会伴随很多的试错。</p><h3 id="5-1-验证数据"><a href="#5-1-验证数据" class="headerlink" title="5.1 验证数据"></a>5.1 验证数据</h3><p>调整超参数时，必须使用超参数专用的确认数据。用于调整超参数的数据，一般称为验证数据（validation data）。我们使用这个验证数据来评估超参数的好坏。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">训练数据用于参数（权重和偏置）的学习，验证数据用于超参数的性能评估。为了确认泛化能力，要在最后使用（比较理想的是只用一次）测试数据。<br></code></pre></td></tr></table></figure><p>根据不同的数据集，有的会事先分成训练数据、验证数据、测试数据三部分，有的只分成训练数据和测试数据两部分，有的则不进行分割。在这种情况下，用户需要自行进行分割。</p><h3 id="5-2-超参数的最优化"><a href="#5-2-超参数的最优化" class="headerlink" title="5.2 超参数的最优化"></a>5.2 超参数的最优化</h3><p>进行超参数的最优化时，逐渐缩小超参数的“好值”的存在范围非常重要。所谓逐渐缩小范围，是指一开始先大致设定一个范围，从这个范围中随机选出一个超参数（采样），用这个采样到的值进行识别精度的评估；然后，多次重复该操作，观察识别精度的结果，根据这个结果缩小超参数的“好值”的范围。通过重复这一操作，就可以逐渐确定超参数的合适范围。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">有报告显示，在进行神经网络的超参数的最优化时，与网格搜索等有规律的搜索相比，随机采样的搜索方式效果更好。这是因为在多个超参数中，各个超参数对最终的识别精度的影响程度不同。<br></code></pre></td></tr></table></figure><p>在超参数的最优化中，减少学习的 epoch，缩短一次评估所需的时间是一个不错的办法。</p><ul><li><p><strong>步骤 0</strong></p><p>设定超参数的范围。</p></li><li><p><strong>步骤 1</strong></p><p>从设定的超参数范围中随机采样。</p></li><li><p><strong>步骤 2</strong></p><p>使用步骤 1 中采样到的超参数的值进行学习，通过验证数据评估识别精度（但是要将 epoch 设置得很小）。</p></li><li><p><strong>步骤 3</strong></p><p>重复步骤 1 和步骤 2（100 次等），根据它们的识别精度的结果，缩小超参数的范围。</p></li></ul><p>在超参数的最优化中，如果需要更精炼的方法，可以使用贝叶斯最优化（Bayesian optimization）。贝叶斯最优化运用以贝叶斯定理为中心的数学理论，能够更加严密、高效地进行最优化。详细内容请参 考 论 文“Practical Bayesian Optimization of Machine Learning Algorithms”等。</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>artificial intelligence</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP基础</title>
    <link href="/2022/11/09/security/PHP%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/11/09/security/PHP%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="PHP基础"><a href="#PHP基础" class="headerlink" title="PHP基础"></a>PHP基础</h1><p>主要介绍 PHP 基础，从 PHP 简介、PHP 基本语法、超全局变量、正则表达式和 PHP 危险<br>函数等几个方面来进一步了解 PHP。</p><h2 id="1-2-1-PHP-简介"><a href="#1-2-1-PHP-简介" class="headerlink" title="1.2.1 PHP 简介"></a>1.2.1 PHP 简介</h2><p>PHP，全称 Hypertext Preprocessor，即超文本预处理器，是一种通用开源脚本语言。PHP 代码在服务器上执行时，结果以纯 HTML 形式返回给浏览器。</p><p>PHP 文件以 .php 为后缀，包含 PHP 代码、HTML 代码及 JS 代码；PHP 代码也可以在 HTML 文档<br>中运行，可以放在任何位置。</p><h2 id="1-2-2-PHP-基本语法"><a href="#1-2-2-PHP-基本语法" class="headerlink" title="1.2.2 PHP 基本语法"></a>1.2.2 PHP 基本语法</h2><p>PHP 脚本以 <strong><?php** 开头，以 **?></strong> 结尾。</p><p>PHP 有三种注释方式，分别是<strong>脚本注释、单行注释和多行注释</strong>。</p><p>PHP <strong>变量以 $ 符号开头</strong>，其后是变量的名称。变量名称必须以字母或下划线开头，并且只能包<br>含字母、数字和下划线。</p><p>在 PHP 中，<strong>有两种基本的输出方法：echo 和 print。</strong>echo 可以输出一个或多个字符串，无返回值；print 只能输出一个字符串，返回值为“1”。还有 <strong>var_dump () 函数</strong>能显示关于一个或多个表达式的结构信息，包括表达式的类型与值。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//php 代码</span><br><span class="hljs-comment"># 脚本注释</span><br><span class="hljs-comment">// 单行注释</span><br><span class="hljs-comment">/* 多行注释 */</span><br><span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;hongri&quot;</span>;<br><span class="hljs-variable">$b</span> = <span class="hljs-string">&quot;sec&quot;</span>;<br><span class="hljs-variable">$c</span> = <span class="hljs-variable">$a</span>.<span class="hljs-variable">$b</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$a</span>.<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<span class="hljs-comment">// 输出 hongri。</span><br><span class="hljs-keyword">print</span> <span class="hljs-variable">$c</span>.<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<span class="hljs-comment">// 输出 hongrisec。</span><br><span class="hljs-title function_ invoke__">var_dump</span> (<span class="hljs-variable">$a</span>);<span class="hljs-comment">// 输出变量的数据类型和值。</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-2-3-运算符"><a href="#1-2-3-运算符" class="headerlink" title="1.2.3 运算符"></a>1.2.3 运算符</h2><ol><li><p>三元运算符</p><p>格式：表达式 1 ？表达式 2：表达式 3<br>含义：如果表达式 1 为真，执行表达式 2；如果表达式 1 为假，则执行表达式 3。</p></li><li><p>字符串运算符</p><p>‘<strong>.</strong>‘起连接作用</p></li><li><p>类型运算符</p><p>instanceof 用于确定一个 PHP 变量是否属于某一类（class）的实例。</p></li></ol><h2 id="1-2-4-和-的区别"><a href="#1-2-4-和-的区别" class="headerlink" title="1.2.4 == 和 === 的区别"></a>1.2.4 == 和 === 的区别</h2><p>== 比较两个变量的值，不比较数据类型；=== 比较两个变量的值和类型。</p><h2 id="1-2-5-超全局变量"><a href="#1-2-5-超全局变量" class="headerlink" title="1.2.5 超全局变量"></a>1.2.5 超全局变量</h2><p>超全局变量是在全部作用域中始终可用的内置变量。在函数或方法中无需执行 global $variable；<br>就可以访问它们。</p><p>这些超全局变量如下。</p><ul><li><p> $GLOBALS：包含了全部变量的全局组合数组。变量的名字就是数组的键。</p></li><li><p> $_SERVER：包含了诸如头信息（header）、路径（path），以及脚本位置（script locations）等信息的数组。这个数组中的项目由 Web 服务器创建。</p></li><li><p> $_GET：通过 URL 参数传递给当前脚本的变量的数组。</p></li><li><p> $_POST：当 HTTP POST 请求的 Content-Type 是 application/x-www-form-urlencoded 或 multipart/form-data 时，会将变量以关联数组形式传入当前脚本。</p></li><li><p> $__REQUEST：默认情况下包含了 $_GET、$_POST 和 $_COOKIE 的数组。</p></li><li><p> $_COOKIE：通过 HTTP Cookies 方式传递给当前脚本的变量的数组。</p></li><li><p> $_SESSION：当前脚本可用 SESSION 变量的数组。</p></li><li><p> $_FILES：通过 HTTP POST 方式上传到当前脚本的项目的数组。</p></li><li><p> $_ENV：通过环境方式传递给当前脚本的变量的数组。</p></li></ul><h2 id="1-2-6-魔术常量和魔术方法"><a href="#1-2-6-魔术常量和魔术方法" class="headerlink" title="1.2.6 魔术常量和魔术方法"></a>1.2.6 魔术常量和魔术方法</h2><ol><li><p>魔术常量</p><p>魔术常量是 PHP 向它运行的任何脚本提供的大量的预定义常量。魔术常量其实不是常量，可以理解为特殊的常量，以下介绍的 5 个魔术常量随位置而改变。</p><ul><li> __LINE__：表示文件中的当前行号。不区分大小写。</li><li> __FILE__：表示文件完整的路径和命名。不区分大小写。</li><li> __FUNCTION__：表示函数名称。区分大小写。</li><li> __CLASS__：表示类的名称。区分大小写。</li><li> __METHOD__：表示类的方法的名称。区分大小写。</li></ul></li><li><p>魔术方法</p><p>都是以两个下划线开头。</p></li></ol><p>未完待续…</p>]]></content>
    
    
    <categories>
      
      <category>Cyberspace Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tools of security</title>
    <link href="/2022/11/09/security/Tools-of-security/"/>
    <url>/2022/11/09/security/Tools-of-security/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="86ffe393f3394b2daf1f341587ba22c2aeae52b1138c862770042da81ab0c69a">1a122d849dea0253b8c2e18440c0e53b93e7c2dc25016e4b4aa4af6362977a04e8ec9a7add1528fb533e3ca54c9feed9a03564d295809821b74678804c493ebaf541d6dfaad94cb4d68cd0892d8b61842e7472f2206bbd5c9341ea2f80ad4a8115e11b8b29c03223a1a5c9f28973e845b76a66a04f1fcae59a838d4e70f516692ad118cb0eea96975afeafc42029a77b2cbece29f077aca05f65b78f4469bcc28d25019211858378e1dcb5d4cee03281f1eba5d5f36d4ec8c2f046029ac10586dcc030d3423e5ea98842816a3f2390b3799cba7f7c2a231edb717b38017a364b0afe4f646b24c65ef6443a58fc25608a1b5862367901a12d5e2400c0cb9e2173e6b5200e9ade2adcdc3f16ac60734fdea310cb2f4e2ecc566b1c1336664b930e90bdf2bdfbc9a4f5f1e18f42b5528fbcce5236aef2d7cc811ad5a873cd7be7da26d8f3dfcf11c708608c6188aefe8ec802fc7927b4a18d1f4b6069477991b5ff147467b303bba34e744554564f6d309b7b49a028d3343118cf7ee60a83c8f4d8fc64143676763f312f1027aa26bd926205df0ffdae23ade47bb2f9dbaccbb454acee12d0983bb454ca63690863c27a96467be1bbbefe2a5341ed543483f0aff8508c777029b0ec021fa22339059e0da97c6caed33deae3b396e149463169ea42066266d1179a069d420242d7003c7f9a49186d82e0994abd6eac6341e457995896a1c6d7b4f6645e8328c8b8a7a7e4236f129f72766428d4a643fde49530a96e086fd94d440321aa92d02c25b6a1447032992f65cd70580175b66e244c194ed4a7b5b1e1827319e24ab9b4d7541da3baf37676995188d7731f030ffa573a0575872daf1d2ba2b6adb4b048fb4469df6a40c016ca8b80e72311cff50909bd3a577ca4624ec95b17873b655e8d76fd08c90c2856628fe1baa2fe423e9c6583f684a8d3280a0b848300add43b85dfb430f7085bbd6bf22997e4d0fb9d8bd88184559bf8085c43ac4c2f80265bcf53b584644f831cf2189b6d4ecf7177b6dd531e12</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">please input password</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Cyberspace Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kali初始配置</title>
    <link href="/2022/11/08/linux/Kali%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/11/08/linux/Kali%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Kali-初始化配置"><a href="#Kali-初始化配置" class="headerlink" title="Kali 初始化配置"></a>Kali 初始化配置</h1><h2 id="1-更换源"><a href="#1-更换源" class="headerlink" title="1. 更换源"></a>1. 更换源</h2><ol><li><p>查找kali源</p><p><a href="https://developer.aliyun.com/mirror/">阿里镜像站</a></p></li><li><p>更换kali源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/apt/sources.list<br></code></pre></td></tr></table></figure></li><li><p>更新升级kali内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br></code></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/qq_53030229/article/details/123125352">Kali更换源</a></p></li></ol><h2 id="2-安装中文输入法（ibus）"><a href="#2-安装中文输入法（ibus）" class="headerlink" title="2. 安装中文输入法（ibus）"></a>2. 安装中文输入法（ibus）</h2><ol><li><p>打开终端，安装ibus输入法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get install ibus ibus-pinyin<br></code></pre></td></tr></table></figure></li><li><p>输入 im-config</p><p>若出错，提示安装zenity</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get install zenity<br></code></pre></td></tr></table></figure></li><li><p>再次输入im-config</p><p>依次点击 “确定”-“是”</p><p>选中<strong>“ibus”</strong>，然后点击确定</p><p>确定后，又会弹出一个框，确定</p></li><li><p>输入 ibus-setup</p><p>“添加-中文-pinyin-添加”即可</p></li><li><p>最后一步，重启即可 (reboot)</p></li></ol><p>参考：<a href="https://zhuanlan.zhihu.com/p/114211319">kali怎么安装中文输入法</a></p><h2 id="3-安装git"><a href="#3-安装git" class="headerlink" title="3. 安装git"></a>3. 安装git</h2><ol><li><p>安装git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get install git<br></code></pre></td></tr></table></figure></li><li><p>添加git服务用户</p><p>邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.email <span class="hljs-string">&quot;email@163.com&quot;</span><br></code></pre></td></tr></table></figure><p>用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;Double-Blank&quot;</span> <br></code></pre></td></tr></table></figure><p>使用命令查看是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --list<br></code></pre></td></tr></table></figure></li><li><p>生成ssh公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;email@163.com&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>在代码托管平台上添加SSH公匙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mousepad /home/advance/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure></li></ol><p>参考：<a href="https://blog.csdn.net/weixin_42815873/article/details/121977771">在kali linux上安装git与push提交</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>Kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker简单命令</title>
    <link href="/2022/11/08/tools/Docker%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/11/08/tools/Docker%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-查看容器"><a href="#1-查看容器" class="headerlink" title="1. 查看容器"></a>1. 查看容器</h2><p>列出已经创建的所有容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps -a    <br></code></pre></td></tr></table></figure><p>列出正在运行的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps -s <br></code></pre></td></tr></table></figure><h2 id="2-启动容器"><a href="#2-启动容器" class="headerlink" title="2. 启动容器"></a>2. 启动容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker start [container ID]<br></code></pre></td></tr></table></figure><h2 id="3-进入已经运行的容器"><a href="#3-进入已经运行的容器" class="headerlink" title="3. 进入已经运行的容器"></a>3. 进入已经运行的容器</h2><p>方法一（推荐）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker attach [container ID]<br></code></pre></td></tr></table></figure><p>方法二（未使用）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it [container ID] /bin/bash<br></code></pre></td></tr></table></figure><h2 id="4-退出容器"><a href="#4-退出容器" class="headerlink" title="4. 退出容器"></a>4. 退出容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><h2 id="5-停用容器"><a href="#5-停用容器" class="headerlink" title="5. 停用容器"></a>5. 停用容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker stop [container ID]<br></code></pre></td></tr></table></figure><p>参考:<a href="https://blog.csdn.net/jghiof/article/details/117687974?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-117687974-blog-124920551.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-117687974-blog-124920551.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=1">Docker简单容器命令</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux intasll Docker</title>
    <link href="/2022/11/08/linux/linux-intasll-Docker/"/>
    <url>/2022/11/08/linux/linux-intasll-Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-安装-Docker"><a href="#Linux-安装-Docker" class="headerlink" title="Linux 安装 Docker"></a>Linux 安装 Docker</h1><h2 id="1-Ubuntu"><a href="#1-Ubuntu" class="headerlink" title="1. Ubuntu"></a>1. Ubuntu</h2><ol><li><p>卸载旧版</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get remove docker docker-engine docker.io containerd runc<br></code></pre></td></tr></table></figure></li><li><p>终端输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt update<br>apt-get install ca-certificates curl gnupg lsb-release<br></code></pre></td></tr></table></figure></li><li><p>安装证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure></li><li><p>写入软件源信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo add-apt-repository <span class="hljs-string">&quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure></li><li><p>启动Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start docker<br></code></pre></td></tr></table></figure></li><li><p>安装工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get -y install apt-transport-https ca-certificates curl software-properties-common<br></code></pre></td></tr></table></figure></li><li><p>重启docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service docker restart<br></code></pre></td></tr></table></figure></li><li><p>查看docker版本 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker version<br></code></pre></td></tr></table></figure></li><li><p>查看镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker images<br></code></pre></td></tr></table></figure></li></ol><p>参考：<a href="https://blog.csdn.net/u012563853/article/details/125295985">Ubuntu安装docker</a></p><h2 id="2-Kali-linux"><a href="#2-Kali-linux" class="headerlink" title="2. Kali linux"></a>2. Kali linux</h2><ol><li><p>添加Docker官方的GPG密钥</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl  -fsSL https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/</span>debian/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure></li><li><p>更新源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;deb https://download.docker.com/linux/debian stretch stable&#x27;</span>&gt; /etc/apt/sources.list.d/docker.list<br></code></pre></td></tr></table></figure></li><li><p>直接导入证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get install apt-transport-https  ca-certificates  curl  gnupg2  software-properties-common<br></code></pre></td></tr></table></figure></li><li><p>系统更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get update<br></code></pre></td></tr></table></figure></li><li><p>安装docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install docker.io<br></code></pre></td></tr></table></figure></li><li><p>检查docker安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker -v<br></code></pre></td></tr></table></figure></li><li><p>docker安装成功后，需要安装compose</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install docker-compose<br></code></pre></td></tr></table></figure></li></ol><p>参考：<a href="https://blog.csdn.net/aodechudawei/article/details/122450720">kali安装docker</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo搭建网站</title>
    <link href="/2022/10/19/others/hexo%E5%BB%BA%E7%AB%99/"/>
    <url>/2022/10/19/others/hexo%E5%BB%BA%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>本网站只做搭建blog及遇到的问题记录</p><h1 id="1-环境安装"><a href="#1-环境安装" class="headerlink" title="1 环境安装"></a>1 环境安装</h1><ol><li><p><strong>安装git</strong></p></li><li><p><strong>安装node</strong></p><p><a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><p>检测node安装是否成功：</p><blockquote><p><code>node -v</code>（返回node版本号）</p><p><code>npm -v</code>（返回npm版本号）</p></blockquote></li><li><p><strong>安装hexo</strong></p><blockquote><p>安装完nodejs后通过以下命令安装hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g <br></code></pre></td></tr></table></figure><p>hexo安装完成后查看版本号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo -v<br></code></pre></td></tr></table></figure></blockquote></li></ol><h1 id="2-初始化操作过程"><a href="#2-初始化操作过程" class="headerlink" title="2 初始化操作过程"></a>2 初始化操作过程</h1><ol><li>在本地建立blog文件夹（注意：以下操作要在blog根目录下执行）</li><li><code>hexo init</code>（初始化hexo）</li><li><code>hexo s</code>（启动hexo,然后就能在本地<a href="https://links.jianshu.com/go?to=http://localhost:4000">http://localhost:4000</a>查看自己的网站了）</li></ol><h1 id="3-连接GitHub与本地"><a href="#3-连接GitHub与本地" class="headerlink" title="3 连接GitHub与本地"></a>3 连接GitHub与本地</h1><p>首先右键打开git bash，然后输入下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;githubname&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;xxxx@xx.com&quot;</span><br></code></pre></td></tr></table></figure><p>用户名和邮箱根据注册的github的信息自行修改。</p><p>然后生成密钥SSH key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;xxxx@xx.com&quot;</span><br></code></pre></td></tr></table></figure><p>打开<a href="https://link.zhihu.com/?target=http://github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随意，输入生成的ssh密钥。</p><p>gitbash输入<code>ssh -T git@github.com</code>，如果如下图Fig1所示，出现你的用户名，那就成功了。</p><img src="/2022/10/19/others/hexo%E5%BB%BA%E7%AB%99/fig1.png"><p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repository: https://github.com/xxxxxxx/xxxxxxx.github.io<br>  branch: master<br></code></pre></td></tr></table></figure><p>repository修改为自己的github项目地址。</p><h1 id="4-发布文章到GitHub"><a href="#4-发布文章到GitHub" class="headerlink" title="4 发布文章到GitHub"></a>4 发布文章到GitHub</h1><ol><li><p><strong>写文章</strong></p><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。</p><p>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p><p>之后打开<code>..\blog\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个是文章文件。</p></li><li><p><strong>发布</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo s//可以本地查看静态网站http://localhost:4000<br>hexo d<br></code></pre></td></tr></table></figure></li></ol><h1 id="5-hexo插件"><a href="#5-hexo插件" class="headerlink" title="5 hexo插件"></a>5 hexo插件</h1><h2 id="5-1-安装hexo-blog-encrypt插件"><a href="#5-1-安装hexo-blog-encrypt插件" class="headerlink" title="5.1 安装hexo-blog-encrypt插件"></a>5.1 安装hexo-blog-encrypt插件</h2><p>可以轻松实现文章加密功能</p><blockquote><ul><li><p>在hexo目录下<code>npm install hexo-blog-encrypt</code></p></li><li><p>在<code>/Hexo/_config.yml</code>文件中添加内容:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">encrypt:</span><br><span class="hljs-string">enable:true</span><br></code></pre></td></tr></table></figure></li></ul></blockquote><p>使用插件：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: Hexo加密功能<br>date: 2019-09-04 23:20:00   <br>tags: [学习笔记,Hexo]<br>categories: Hexo      <br>password: smile   <br>abstract: Welcome to my blog, enter password to read. <br><span class="hljs-section">message: 密码输入框上描述性内容</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><h1 id="6-问题"><a href="#6-问题" class="headerlink" title="6 问题"></a>6 问题</h1><h2 id="6-1-Git"><a href="#6-1-Git" class="headerlink" title="6.1 Git"></a>6.1 Git</h2><ol><li><p><strong>重置 windows 10后，因为更新了用户名，造成之前的所以 git 仓库，都无法直接拉取代码</strong></p><p><strong>解决方案：</strong>选择git仓库文件夹-&gt;右键-&gt;属性-&gt;安全-&gt;高级-&gt;所有者更改-&gt;高级-&gt;立即查找-&gt;找到当前账户-&gt;确定-&gt;勾选替换子容器和对象所有者、使用可从对象继承的权限项目替换所有子对象的权限项目。</p></li><li><p><strong>运行git命令出现lf will be replaced by crlf 的解决方法</strong></p><p><strong>解决方案：</strong>出现这样的现象的解决思路windows中的换行符为 CRLF， 而在Linux下的换行符为LF，所以在执行add ，具体操作在方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">rm</span> -rf .git  // 删除.git <br>$ git config --global core.autocrlf <span class="hljs-literal">false</span>  //禁用自动转换<br></code></pre></td></tr></table></figure><p>然后重新执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git init  <br>$ git add .<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-2-公式格式"><a href="#6-2-公式格式" class="headerlink" title="6.2 公式格式"></a>6.2 公式格式</h2><ol><li><p>发现一个问题, 多行公式无法换行. 使用转义（<code>\\\\</code>替换<code>\\</code>无效）</p><ol><li><p>使用\displaylines</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$$ <br>\displaylines&#123;a \\<br>b&#125;<br>$$<br></code></pre></td></tr></table></figure></li><li><p>使用{align}或者{aligned}</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$$<br>\begin&#123;aligned&#125;<br>h \leftarrow h + \frac&#123;\partial L&#125; &#123;\partial W&#125; .<span class="hljs-emphasis">* \frac&#123;\partial L&#125; &#123;\partial W&#125;\\\\# 换行符</span><br><span class="hljs-emphasis">W \leftarrow W -\eta \frac&#123;1&#125; &#123;\sqrt&#123;h&#125; &#125; \frac&#123;\partial L&#125; &#123;\partial W&#125;</span><br><span class="hljs-emphasis">\end&#123;aligned&#125;</span><br><span class="hljs-emphasis">$$</span><br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="6-3-图片"><a href="#6-3-图片" class="headerlink" title="6.3 图片"></a>6.3 图片</h2><h3 id="6-3-1-图片部署在网站上不能显示"><a href="#6-3-1-图片部署在网站上不能显示" class="headerlink" title="6.3.1 图片部署在网站上不能显示"></a>6.3.1 图片部署在网站上不能显示</h3><p>使用以下格式引用图片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;xxx\xxxx.png&quot;</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="6-3-2-图片位置"><a href="#6-3-2-图片位置" class="headerlink" title="6.3.2 图片位置"></a>6.3.2 图片位置</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图片路径&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>此处的center可以更换<br>left（左对齐）、right（右对齐）、center（居中）</p><h2 id="6-4-npm"><a href="#6-4-npm" class="headerlink" title="6.4 npm"></a>6.4 npm</h2><h3 id="6-4-1-安装模块显示ERR！"><a href="#6-4-1-安装模块显示ERR！" class="headerlink" title="6.4.1 安装模块显示ERR！"></a>6.4.1 安装模块显示ERR！</h3><div align="center"><img src="/2022/10/19/others/hexo%E5%BB%BA%E7%AB%99/npm-install-encrypt-Q.png"></div><p>解决方法：设置npm为阿里镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BLOG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>Questions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP基本概念</title>
    <link href="/2022/10/17/computer_science/HTTP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/10/17/computer_science/HTTP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h1><p><strong>HTTP：</strong> Hyper Text Transfer Protocol ,超文本传输协议</p><p><strong>消息模型</strong> ： 客户端发送一条请求消息，而后由服务器返回一条响应消息。</p><h2 id="1-HTTP基本概念"><a href="#1-HTTP基本概念" class="headerlink" title="1.HTTP基本概念"></a>1.HTTP基本概念</h2><p>所有HTTP信息（请求与响应）中都包含一个或几个单行显示的消息头（header），然后是一个强制空白行，最后是消息主体（可选）。</p><p><strong>HTTP请示头</strong>：</p><ul><li><p><strong>GET:</strong> 主要作用是从Web服务器获取一个资源。GET请求并没有消息主题，因此在消息头后的空白行中没有其他数据。它所请求的URL通常由所请求的资源名称，以及一个包含客户端向该资源提交的参数的可选查询字符串组成。HTTP版本为1.1必须使用Host请求。</p></li><li><p><strong>HOST消息头：</strong> 用于指定出现在被访问的完整URL中的主机名称。如果几个Web站点以相同的一台服务器为主机，就需要使用Host消息头，因为请求第一行中的URL内通常并不包含主机名称。</p></li><li><p><strong>Accept</strong> ：Accept表示浏览器支持的MIME(Multipurpose Internet Mail Extensions , 多用途互联网邮件扩展)类型；浏览器支持的类型：</p><blockquote><p>text: 用于标准化表示的文本信息</p><p>text/html:表示html文档</p><p>application:用于传输应用程序数据或二进制数据</p><p>application/xhtml+xml:表示xhtml文档</p><p>application/xml:表示xml文档</p></blockquote><p>优先顺序是从左到右的排列顺序。</p></li><li><p><strong>Referer消息头：</strong> 用于表示发出请求的原始URL</p></li><li><p><strong>Accept-Language：</strong> 浏览器支持的语言</p></li><li><p>q是权重系数，范围0&lt;=q&lt;=1。q值越大，请求越倾向于“；”之前的类型表示的内容。若没有指定q，默认为1；若为0，用于提醒服务器哪些是浏览器不接受的内容类型</p></li><li><p><strong>User-Agent消息头：</strong> 提供与浏览器或其他生成请求的客户端软件有关的信息。</p></li><li><p><strong>Accept-Encoding:</strong> 浏览器支持的压缩编码是gzip和deflate</p></li><li><p><strong>Cookie消息头：</strong> 用于提交服务器向客户端发布的其他参数</p></li><li><p><strong>Connection：</strong> 表示持久的客户端与服务连接。</p></li></ul><h2 id="2-HTTP响应"><a href="#2-HTTP响应" class="headerlink" title="2.HTTP响应"></a>2.HTTP响应</h2><p>​    服务器响应返回的代码：</p><ul><li>HTTP/1.1 表示HTTP版本</li><li>200表示请求结果的数字状态码</li><li><strong>Server</strong>： 消息头中包含一个旗标，指明所使用的Web服务器软件。</li><li><strong>Set-Cookie</strong>: 消息头向浏览器发送另一个Cookie，它将在随后向服务器发送的请求中由Cookie消息头返回。</li><li><strong>Pragma：</strong>消息头指示浏览器不要将响应存在缓存中。</li><li><strong>Expires：</strong>消息头指出响应内容已经过期，因此不应保存在缓存中。当返回动态内容时常常会发送这些指令，以确保浏览器随时获得最新内容。</li></ul><p>除了GET和POST方法以外，HTTP协议还支持许多其他因特殊目的建立的方法，具体如下：</p><ul><li><strong>HEAD</strong>:方法的功能与GET方法相似，不同之处在于服务器不会在其响应中返回消息主体。这种方法可用于检查某一资源在向其提交GET请求钱是否存在。</li><li><strong>TRACE</strong>：主要用于诊断。用于检测客户端与服务器之间是否存在任何操纵请求的代理服务器。</li><li><strong>OPTIONS</strong>：这种方法要求服务器报告对某一特殊资源有效的HTTP方法。</li><li><strong>PUT</strong>：这个方法试图使用包含在请求主体的内容，向服务器上传指定的资源。</li></ul><h3 id="2-1-HTTP消息头"><a href="#2-1-HTTP消息头" class="headerlink" title="2.1 HTTP消息头"></a>2.1 HTTP消息头</h3><ol><li>请求消息头<ul><li>Host: 用来告知服务器，请求的资源所处的互联网主机名和端口号</li><li>User-Agent： 提供与浏览器或生成请求的其他客户端软件有关的信息</li><li>Accept： 告知服务器，客户端愿意接受哪些内容</li><li>Accept-Language</li><li>Accept-Encoding</li><li>Content-Type：表示具体请求中的媒体类型信息，确切的是客户端告知服务端，自己即将发送的请求消息携带的数据结构类型，好让服务端接收后以合适的方式处理。</li><li>Origin： 这个消息头用在跨域Ajax请求中，用于指示提出请求的域。</li><li>Referer： 这个消息头用于指示提出当前请求的原始URL</li><li>Cookie： 用于向服务器提交它以前发布的Cookie</li></ul></li><li>响应消息头<ul><li>Content-Type: 返回内容的MIME类型</li><li>Date：原始服务器消息发出的时间</li><li>Server： 提供所使用的Web服务器软件的相关信息</li><li>Set-Cookie：用于向浏览器发布Cookie，浏览器在随后的请求中将其返回给服务器。</li><li>Transfer-Encoding</li><li>Vary：告诉下游代理是使用缓存响应还是从原始服务器请求。</li><li>X-Frame-Options：指示浏览器框架是什么以及如何加载当前响应。</li></ul></li></ol><h3 id="2-2-Cookie"><a href="#2-2-Cookie" class="headerlink" title="2.2 Cookie"></a>2.2 Cookie</h3><p>​        服务器使用Cookie机制向客户端发送数据，客户端保存Cookie并将其返回服务器。与其他类型的请求参数（存在于URL查询字符串或消息主体中）不同，无需应用程序或用户采取任何措施。随后的每一个请求都会继续重新向服务器提交Cookie。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Set-Cookie: <span class="hljs-attribute">tarcking</span>=tI8rk7joMx44S2Uu85nSWc<br><br>Cookie:<span class="hljs-attribute">tracking</span>=tI8rk7joMx44S2Uu85nSWc<br></code></pre></td></tr></table></figure><p>​        如上所示，Cookie一般由一个名/值对构成，但也可包含任何不含空格的字符串。可以在服务器响应中使用几个Set-Cookie消息头发布多个Cookie，并可在同一个Cookie消息头中用分号分隔不同的Cookie，将他们全部返回给服务器。</p><p>​        除Cookie的实际位外，Set-Cookie消息头可以包含一下任何可选属性</p><blockquote><p>Expires: 用于设定Cookie的有效时间</p><p>Domain：用于指定Cookie的有效域</p><p>Path：用于指定Cookie的有效URL</p><p>Secure： 如果设置这个属性，则仅在HTTPS请求中提交Cookie</p><p>HTTPOnly：如果设置这个属性，将无法通过客户端JavaScript直接访问Cookie</p></blockquote><h2 id="3-状态码"><a href="#3-状态码" class="headerlink" title="3.状态码"></a>3.状态码</h2><p>状态码可以分为五类：</p><blockquote><ol><li>1xx–提供信息。</li><li>2xx–请求被成功提交。</li><li>3xx–客户端被重定向其他资源。</li><li>4xx–客户端错误。</li><li>5xx–服务器执行请求时遇到错误</li></ol></blockquote><h2 id="4-URL编码"><a href="#4-URL编码" class="headerlink" title="4.URL编码"></a>4.URL编码</h2><p>​        URL只允许使用US-ASCII字符集中的可打印字符（也就是ASCII代码在0x20-0x27范围内的字符），而且，由于其在URL方案或HTTP协议内具有特殊含义，这个范围内的一些字符也不能用在URL中。</p><p>​        URL编码方案主要用于对扩展ASCII字符集中的任何有问题的字符进行编码，使其可通过HTTP安全传输。任何URL编码的字符都以“%”为前缀，其后是这个字符的两位十六进制ASCII代码。以下是常见的URL编码字符：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">3d</span></span> 代表= ； <br><span class="hljs-tag">%<span class="hljs-selector-tag">25</span></span> 代表% ； <br><span class="hljs-tag">%<span class="hljs-selector-tag">20</span></span> 代表空格； <br><span class="hljs-tag">%<span class="hljs-selector-tag">0a</span></span> 代表新行； <br><span class="hljs-tag">%<span class="hljs-selector-tag">00</span></span> 代表空字节<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中文乱码</title>
    <link href="/2022/05/29/algorithms%20and%20programming/%E4%B9%B1%E7%A0%81/"/>
    <url>/2022/05/29/algorithms%20and%20programming/%E4%B9%B1%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><pre><code class="hljs">比特位（Bit）：是计算机最小的存储单位，以0或1来表示比特位的值字节（Byte）：是计算机中数据存储的基本单元，一字节等于一个8个比特位字符（Character）：是一个信息单位，是各种文字和符号的统称字符集（Character Set）：是某个范围内字符的集合，不同的字符集规定了不同字符的个数字符码（Code Point）：字符集中每个字符的数字编号字符编码（Character Encoding）：是将字符集中的字符码映射为字节流的一种具体实现方案，常见有ASCII 编码、UTF-8 编码、GBK 编码编码（Encoding）：编码的过程是将字符转换成字节流解码 （Decoding）：解码的过程是将字节流解析为字符</code></pre><h1 id="乱码原因"><a href="#乱码原因" class="headerlink" title="乱码原因"></a>乱码原因</h1><p>计算机存储字符：</p><ul><li>首先把字符转换成数字</li><li>直接存储数字</li></ul><p>这样会产生两个问题：1.按照怎样的规范把字符转换成数字？2.按照怎样的方式存储数字（如：使用多少个字节？）</p><p><strong>所以乱码的解决方法也就从两个角度出发：编码与译码是否使用同一种方式；存储数字方式是否相同。</strong></p><p><em>注：utf-8采用可变字节存储方式</em></p>]]></content>
    
    
    <categories>
      
      <category>common problem</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Garbled code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python注释</title>
    <link href="/2022/05/29/algorithms%20and%20programming/Python%E6%B3%A8%E9%87%8A/"/>
    <url>/2022/05/29/algorithms%20and%20programming/Python%E6%B3%A8%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="注释的分类"><a href="#注释的分类" class="headerlink" title="注释的分类"></a>注释的分类</h1><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><p>利用    “<code>#</code> “<br>例如    <code># 单行注释 - 在此处写下下一行代码的含义</code></p><h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;&#x27;&#x27;  注释信息 &#x27;&#x27;&#x27;</span><br><span class="hljs-string">&quot;&quot;&quot; 注释信息 &quot;&quot;&quot;</span><br>多行行首添加<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h2 id="特殊注释"><a href="#特殊注释" class="headerlink" title="特殊注释"></a>特殊注释</h2><p><code>#!/usr/bin/python</code> 表明python解释器所在路径，一般在Linux下使用</p><p><code># encoding=utf-8</code>（中文支持）<br><strong>注：Python3直接支持，Python2默认不支持</strong><br><strong># encoding=utf-8、# coding=utf-8</strong><br><strong>正规的Python推荐写法：# <em>*</em> coding:utf-8 <em>*</em></strong></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
